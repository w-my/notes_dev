# 内存模型

ARC不是万能的，他可以解决大部分情况下的内存管理问题，在有些框架中和某些使用到C语言的场景中还是需要开发者手动对内存进行管理。

## 内存架构：

| 内存区域 |                     作用                     |
| :------: | :------------------------------------------: |
|  栈 区   |   存储局部变量，在作用域结束后内存会被回收   |
|  堆 区   |     存储OC对象，需要开发者手动申请和释放     |
|  BSS区   |     用来存储未初始化的全局变量和静态变量     |
|  数据区  | 用来存储已经初始化的全局变量、静态变量、常量 |
|  代码段  |                   加载代码                   |

## 引用计数

在面向对象语言中，内存管理通常会由模型机制来完成，常见的有垃圾回收和引用计数两种内存管理模型。
 其实每一个OC对象都有一个retainCount属性，这个属性其实就是一个计数器。
 一个OC对象是否应该被释放取决于其他地方对他的引用情况，每有一个地方引用它，他自身的引用计数就+1，当有一个地方不再引用，则其引用计数-1，最终根据其引用计数值是否为0来确定这块内存是否被回收。

## MRC内存管理

Xcode默认开启ARC功能，可以在配置中将其关闭

![img](https:////upload-images.jianshu.io/upload_images/3692367-78eaea5f160b1f6f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)


**MRC内存管理的两个原则：**



- 谁持有对象，谁负责释放，不是自己持有的不能释放
- 当对象不在被需要时，要主动释放

**OC中会对对象进行持有的方法**

|   函数名    |       意义       |
| :---------: | :--------------: |
|    alloc    |   进行内存分配   |
|     new     | 创建并初始化对象 |
|    copy     |     复制对象     |
| mutablecopy |   可变复制对象   |
|   retain    |     进行持有     |

## ARC内存管理

ARC是Xcode编译器的功能，ARC只做了一件事，就是在编译时帮助开发者将retain和release方法补上。
 编译器会自动帮助我们进行retain的添加，我们唯一要做的就是使用指针指向这个对象，当指针被置空或者被指向新值时，原来的对象会被release一次。同样，对于自己生成的对象，其离开作用域时，编译器也会为其添加一个release操作。
 **ARC中有几个重要的修饰关键字：(所有权修饰符)**__strong、__weak、__unsafe_unretained、__autoreleasing
 **实际上，我们使用的指针默认都是使用__strong关键字修饰的**

**__strong通常用来对变量进行强引用，主要有三个作用：**

- 使用__strong修饰的变量如果是自己生成的，则会被添加进自动释放池，在作用域结束后，会被release一次
- 使用__strong修饰的变量如果不是自己生成的，则会被强引用，即会被持有使其引用计数+1，在离开作用域后会被release一次
- 使用__strong修饰的变脸个指针如果重新赋值，或者置为nil，则变量会被release一次

**__weak修饰符通常用来对变量进行弱引用，主要有两个作用：（避免ARC环境下的循环引用问题）（循环引用是ARC中造成内存泄漏的主要问题）**

- 被__weak修饰的变量仅提供弱引用，不会使其引用计数增加。变量对象如果是自己生成的，则会被添加到自动释放池，会在离开作用于时被release一次，如果不是自己生成的，则在离开作用域后，不会进行release操作
- 被__weak修饰的变量指针，变量如果失败，则指针会被自动置为nil，这是一个比较安全的设计方式，大量减少野指针造成的异常

**__unsafe_unretained修饰符**
 不安全的修饰符，与weak相比，这个修饰符的作用 也是对变量进行弱引用，不同的是，当变量对象失效时，其指针不会被自动置为nil。

- 被__unsafe_unretained修饰的变量仅提供弱引用，不会使其引用计数增加。如果是自己生成的，会在离开作用域时被release一次，如果不是自己生成的，则在离开作用域后，不会进行release操作
- 当变量失效后，被修饰指针不会被安全处理为nil，旧地址依然保存

**__autoreleasing修饰符与自动释放池有关**

**在ARC时，要注意以下几条原则：**

- 不能使用retain、release、autorelease，不可访问retainCount属性
- 不能调用dealloc函数，可以覆写dealloc函数，但是在实现中不可调用父类的dealloc函数
- 不能使用NSAutoreleasePool，可以使用@autoreleasepool代替
- 对象型变量不能作为C语言的结构体

**属性修饰符：**
 @property 修饰符，编译器帮助我们生成getter和setter方法
 声明属性编译器默认使用__strong修饰符

> 内存管理相关属性修饰符举例

|       名称        |                             作用                             |
| :---------------: | :----------------------------------------------------------: |
|      assign       | 直接赋值，和引用计数无关，用来声明简单数据类型的属性，如int  |
|      retain       | 对旧对象进行释放，并强引用新的对象，使其引用计数+1，用在MRC中 |
|      strong       | 对新对象进行强引用，释放旧对象，使其引用计数+1，作用于retain相似，用在ARC中 |
|       copy        |  在实现Setter方法时，采用copy函数，会生成新的对象被自己持有  |
|       weak        | 弱引用，不对所赋值的对象进行持有，但是是安全的，当对象不可用时置为nil，用在ARC |
| unsafe_unretained | 弱引用，如果引用对象不可用，指针不会被置为nil，会产生野指针  |