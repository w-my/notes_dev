//
//  main.m
//  内存管理-内存布局
//
//  Created by WTW on 2019/8/26.
//  Copyright © 2019 wtw. All rights reserved.
//

/*
 iOS 程序的内存布局
 
 低地址
 
        代码段         编译之后的代码
    
        数据段         字符串常量；已初始化数据(已初始化的全局变量、静态变量等)；未初始化的数据(未初始化的全局变量、静态变量等)
 
        堆(低到高)     通过alloc、malloc、calloc等动态分配的空间，分配的内存空间地址越来越大
 
        栈(高到低)     函数调用开销，比如局部变量。分配的内存空间地址越来越小
 
        内核区
 
 高地址
 */

#import <Foundation/Foundation.h>

int a = 10;  // 已初始化全局变量
int b;  // 未初始化全局变量

int main(int argc, char * argv[]) {
    @autoreleasepool {
        static int c = 20; // 已初始化静态变量

        static int d;  // 未初始化静态变量

        int e;
        int f = 20;

        // 字符串常量
        NSString *str = @"123";
        NSString *str2 = @"123";
        NSLog(@"\n str: %p \n str2: %p",str,str2);

        // 堆空间
        NSObject *obj = [[NSObject alloc] init];
        NSArray *arr = [NSArray array];
        
        NSLog(@"\n字符串常量    &str=%p\n已初始化全局变量&a=%p\n未初始化全局变量&b=%p\n已初始化静态变量&c=%p\n未初始化静态变量&d=%p\n堆地址      &obj=%p\n栈局部变量     &e=%p\n栈局部变量     &f=%p\n",
             str, &a, &b, &c, &d, &obj,&e, &f);
        
        return 0;
    }
}


/*
 字符串常量
 str=0x10dfa0068
 
 已初始化的全局变量、静态变量
 &a =0x10dfa0db8
 &c =0x10dfa0dbc
 
 未初始化的全局变量、静态变量
 &d =0x10dfa0e80
 &b =0x10dfa0e84
 
 堆
 obj=0x608000012210
 
 栈
 &f =0x7ffee1c60fe0
 &e =0x7ffee1c60fe4
 */


# mark - 内存的分页和分段

/*
 分段：根据程序(进程)需要开辟一段(一段有多大牵扯到分区的算法) 虚拟的地址空间地址从 0x00000000 开始，和实际的物理地址空间一样大小，然后两块空间一一映射，即虚拟空间中的每个字节对应物理内存中的每个字节；
     分段的作用：
        主要是为了做到地址隔离，不需要关心物理地址的变化只需要按照虚拟内存来寻址即可；
     存在的问题：
        没有解决内存使用效率的问题，对内存区域的映射是按照程序为单位，如果内存不足，被换如换出的过程会照成大量磁盘的访问操作，从而严重影响速度；
 
    每个进程都有一个专门存放进程信息的数据结构，即PCB,当进程切换的时候，PCB 跟着一起切换这个基地址；物理地址=基地址(段的起始地址)+逻辑地址；
 
 分页：把地址空间人为分成固定大小的页，每一页的大小由硬件决定，或硬件支持多种大小的页，由操作系统决定页的大小；intel 系列的处理器支持4KB，2M、1G 大小的页，同一时刻只能选择一种大小，故对于整个系统来说页是固定大小的；（PC 基本上都是4KB 一页）
    
    
 */
