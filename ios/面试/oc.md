OC部分
## 1.什么是runtime？
1.runtime 运行时机制，是一套比较底层的纯 C 语言 API , 属于1个 C 语言库, 包含了很多底层的 C 语言 API 。(引入 <objc/runtime.h> 或者 <objc/message.h> )
2.程序运行过程时，我们平时编写的 OC 代码, 其实最终都是转成了 runtime 的 C 语言代码。
3.在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才能根据函数的名称找到对应的函数来调用。

2.runtime 是干什么用的？使用场景是什么？
1.OC的动态性就是由Runtime来支撑和实现的，Runtime是一套C语言的API，封装了很多动态性相关的函数
2.利用关联对象（AssociatedObject）给分类添加属性
3.遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档）
4.利用消息转发机制解决方法找不到的异常问题
5.KVC、KVO都是基于runtime实现的。

3.讲一下 OC 的消息机制
1.当向一个对象发送消息时，objc_msgSend 方法根据对象的 isa 指针找到对象的类，然后在类的调度表（dispatch table）中查找 selector。
2.如果无法找到 selector，objc_msgSend 通过指向父类的指针找到父类，并在父类的调度表（dispatch table）中查找 selector，以此类推直到 NSObject 类。
3.一旦查找到 selector，objc_msgSend 方法根据调度表的内存地址调用该实现。
4.通过这种方式，message 与方法的真正实现才在执行阶段进行绑定。
5.为了保证消息发送与执行的效率，系统会将全部 selector 和使用过的方法的内存地址缓存起来。
6.每个类都有一个独立的缓存，缓存包含有当前类自己的 selector 以及继承自父类的 selector。
7.查找调度表（dispatch table）前，消息发送系统首先检查 receiver 对象的缓存；缓存命中的情况下，消息发送（messaging）比直接调用方法（function call）只慢一点点。

4.动态绑定
1,在运行时确定要调用的方法，动态绑定将调用方法的确定也推迟到运行时。
2.在编译时，方法的调用并不和代码绑定在一起，只有在消实发送出来之后，才确定被调用的代码。
3.通过动态类型和动态绑定技术，您的代码每次执行都可以得到不同的结果。
4.运行时负责确定消息的接收者和被调用的方法；运行时的消息分发机制为动态绑定提供支持。
5.当您向一个动态类型确定了的对象发送消息时，运行环境系统会通过接收者的 isa 指针定位对象的类，并以此为起点确定被调用的方法，方法和消息是动态绑定的。而且，您不必在 Objective-C 代码中做任何工作，就可以自动获取动态绑定的好处。
6.您在每次发送消息时，特别是当消息的接收者是动态类型已经确定的对象时，动态绑定就会例行而透明地发生。

5.讲一下isa指针
1.isa 等价于 is kind of
实例对象 isa 指向类对象
类对象 isa 指向元类对象
元类对象的 isa 指向元类的基类

6.iOS中实现多线程的几种方案，各自有什么特点？
1.NSThread 面向对象的，需要程序员手动创建线程，但不需要手动销毁。子线程间通信很难。
2.GCD c语言，充分利用了设备的多核，自动管理线程生命周期。比NSOperation效率更高。
3.NSOperation 基于gcd封装，更加面向对象，比gcd多了一些功能。

7.GCD执行原理？
1.GCD有一个底层线程池，这个池中存放的是一个个的线程。之所以称为“池”，很容易理解出这个“池”中的线程是可以重用的，当一段时间后这个线程没有被调用的话，这个线程就会被销毁。注意：开多少条线程是由底层线程池决定的（线程建议控制在3~5条），池是系统自动来维护，不需要我们程序员来维护。 而我们程序员需要关心的是什么呢？我们只关心的是向队列中添加任务，队列调度即可。

2.如果队列中存放的是同步任务，则任务出队后，底层线程池中会提供一条线程供这个任务执行，任务执行完毕后这条线程再回到线程池。这样队列中的任务反复调度，因为是同步的，所以当我们用currentThread打印的时候，就是同一条线程。
如果队列中存放的是异步的任务，（注意异步可以开线程），当任务出队后，底层线程池会提供一个线程供任务执行，因为是异步执行，队列中的任务不需等待当前任务执行完毕就可以调度下一个任务，这时底层线程池中会再次提供一个线程供第二个任务执行，执行完毕后再回到底层线程池中。

3.这样就对线程完成一个复用，而不需要每一个任务执行都开启新的线程，也就从而节约的系统的开销，提高了效率。在iOS7.0的时候，使用GCD系统通常只能开58条线程，iOS8.0以后，系统可以开启很多条线程，但是实在开发应用中，建议开启线程条数：3~5条最为合理。

8.多个网络请求完成后执行下一步
1.使用GCD的dispatch_group_t
每次网络请求前先dispatch_group_enter（进入）,请求回调后再dispatch_group_leave（离开），enter和leave必须配合使用，有几次enter就要有几次leave，否则group会一直存在。
当所有enter的block都leave后，会执行dispatch_group_notify的block。
2.使用GCD的信号量dispatch_semaphore_t

9.异步操作两组数据时, 执行完第一组之后, 才能执行第二组
这里使用dispatch_barrier_async栅栏方法即可实现

10.什么情况使用 weak 关键字，相比 assign 有 什么不同?
1.在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决, 比如:delegate 代理属性， 自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak;当然，也可以使用 strong，但是建议使用 weak

2.weak 策略在属性所指的对象遭到摧毁时，系统会将 weak 修饰的属性对象的指针指 向 nil，在 OC 给 nil 发消息是不会有什么问题的; 如果使用 assign 策略在属性所指 的对象遭到摧毁时，属性对象指针还指向原来的对象，由于对象已经被销毁，这时候就产生了野指针，如果这时候在给此对象发送消息，很容造成程序奔溃 assigin 可以用于修饰非 OC 对象,而 weak 必须用于 OC 对象

11.怎么用 copy 关键字?
1.NSString、NSArray、NSDictionary 等等经常使用 copy 关键字，是因为他们有对应 的可变类型:NSMutableString、NSMutableArray、NSMutableDictionary，为确保 对象中的属性值不会无意间变动，应该在设置新属性值时拷贝一份，保护其封装性

2.block 也经常使用 copy 关键字,方法内部的 block 默认是 在栈区的,使用 copy 可以把它放到堆区.

12.怎么样优化APP启动速度？
1.在main函数执行之前
1.1尽量删除一些不必要的系统文件和第三方库。
1.2尽量删除一些不必要的.h .m 文件。
1.3尽量不要在类的load函数放入大量初始化信息，这样会延迟加载时间。

2.didfinishlauch函数到第一个主界面加载显示阶段
2.1减少不必要的网络请求。
2.2减少不必要的数据初始化操作，尽量写成懒加载
2.3减少一些第三方sdk的初始化和版本检测相关代码

13.UIView 和 CALayer 的区别？
UIView 是 CALayer 的 delegate，UIView 可以响应事件，而 CA Layer 则不能。

14.KVC 的主要应用的场景与注意的事项
KVC全称（key-Value coding）称呼为键值编码，在iOS开发中。允许开发者通过key名直接访问对象的属性，或者给对象的属性赋值。需要调用明确的存取方法，这样就可以在运行时动态访问和修改对象的属性，而不是在编译时确定。

15.iOS类别的作用？继承和类别在实现中有何区别？
category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改。 并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类别具有更高的优先级。
类别主要有3个作用：
(1)将类的实现分散到多个不同文件或多个不同框架中。
(2)创建对私有方法的前向引用。
(3)向对象添加非正式协议。 继承可以增加，修改或者删除方法，并且可以增加属性。
生效周期：Category是runtime，Extension是编译时。
Category可以为系统类添加分类，Extension不能。
文件：Category是有h声明和m实现，Extension直接写在宿主.m文件，只有h声明。
Category只能扩充方法，不能扩充成员变量和属性，因为成员变量是编译时的，属性会在编译时自动生成setter和getter，但Category是runtime。

16.KVO是什么？简述KVO的实现原理。KVO是否能监听数组？如何实现？
KVO（键值观察）：它可以使对象获取其他对象属性变化的通知机制。

调用KVC会触发KVO。

KVO使用了isa-swizzling方式结合RunTime动态性，在给对象首次添加KVO时，RunTime会动态创建被监听对象的子类（NSKVONofifying_ClassName），然后实现setter，class，dealloc，_isKVOA方法，并在setter方法中实现对应通知机制。接下来将被监听对象isa指向动态创建的子类。使用KVC修改属性值时，会调用动态创建的子类中对应setter方法，触发通知机制，如此便实现了KVO。

KVO监听数组需实现 NSMutableArray 的增删改操作遵从 KVC 的规则：

增： -insertObject:inAtIndex: 或者 -insert:atIndexes:
删： -removeObjectFromAtIndex: 或者 -removeAtIndexes:
改：-replaceObjectInAtIndex:withObject: 或者 -replaceAtIndexes:with:
并将这些接口暴露给调用者，在对数组进行操作时需使用上述实现的接口。

16.如何理解RunLoop
在主线程中默认开启RunLoop,它不断地监听系统事件，如触摸事件、定时器事件等，一旦有事件发生，就会通知相应的处理方法来处理该事件。

